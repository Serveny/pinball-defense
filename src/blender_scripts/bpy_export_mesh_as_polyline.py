import os
from pathlib import Path
import bpy
from bpy.types import MeshPolygon, MeshVertex, MeshEdge
from mathutils import Vector

# Scripf for export mesh as list of 2D polyline colliders
dir_name = Path(__file__).parent.parent
file_name = os.path.join(dir_name, "../../src/game/colliders.rs")
face_thickness = 0.001

print("\n-------------------------------------\n")

mesh = bpy.context.active_object
if mesh.type != "MESH":
    raise Exception("Selected object is no mesh")
faces: list[MeshPolygon] = mesh.data.polygons
vertices: list[MeshVertex] = mesh.data.vertices
edges: list[MeshEdge] = mesh.data.edges


def only_same_z(verts: list[Vector]) -> tuple[Vector, Vector]:
    a = verts[0]
    b = next(
        pos
        for i, pos in enumerate(verts)
        if i != 0 and round(pos.z, 4) == round(a.z, 4)
    )
    return (Vector((a.x, a.y)), Vector((b.x, b.y)))


edges: list[tuple[tuple[float, float], tuple[float, float]]] = []
for point in faces:
    verts: tuple[Vector, Vector] = only_same_z(
        [vertices[key].co for key in point.vertices]
    )
    edges.append(
        (
            (round(verts[0].x, 2), round(verts[0].y, 2)),
            (round(verts[1].x, 2), round(verts[1].y, 2)),
        )
    )


def find_succ_edge_i(exclude_i: int, point: Vector) -> int:
    for i, e in enumerate(edges):
        if i != exclude_i and (e[0] == point or e[1] == point):
            return i


def add_succ_points(i: int, res: list[Vector]):
    edge = edges[i]
    if not edge[0] in res:
        res.append(edge[0])
        next_i = find_succ_edge_i(i, edge[0])
        if next_i is not None:
            add_succ_points(next_i, res)
    if not edge[1] in res:
        res.append(edge[1])
        next_i = find_succ_edge_i(i, edge[1])
        if next_i is not None:
            add_succ_points(next_i, res)


def find_edge_i_not_in_res(res: list[list[tuple[float, float]]]) -> int | None:
    found_points = [item for sublist in res for item in sublist]
    for i, edge in enumerate(edges):
        if not edge[0] in found_points and not edge[1] in found_points:
            return i
    return None


colliders: list[list[tuple[float, float]]] = []
start: int | None = 0

for i, edge in enumerate(edges):
    for point in edge:
        fn = lambda e: e[0] != i and (e[1][0] == point or e[1][1] == point)
        if next(filter(fn, enumerate(edges)), None) is None:
            start = i

while start is not None:
    points = []
    add_succ_points(start, points)
    colliders.append(points)
    start = find_edge_i_not_in_res(colliders)


with open(file_name, "w") as file:
    file.write(
        """// File generated by blender script
use crate::prelude::*;

#[allow(clippy::approx_constant, clippy::excessive_precision)]
pub fn colliders() -> Vec<Collider> {
    """
    )

    file.write("    vec![\n")
    for coll in colliders:
        # Close the circle
        coll.append(coll[0])
        file.write("        Collider::polyline(vec![\n")
        for point in coll:
            file.write(f"           Vec2::new({point[0]:f}, {point[1]:f}),\n")
        file.write("        ], None),\n")
    file.write("    ]\n")
    file.write("}")
